
let fs = require('fs-extra');
let fg = require('fast-glob');
let path = require('path');
let util = require('util');
let chalk = require('chalk');
let yargs = require('yargs');
let Diff = require('diff');

let argv = yargs
  .option('verbose', {alias: 'v', type: 'boolean'})
  .option('organizedBy', {choices: ['type', 'change']})
  .option('rawNames', {type: 'boolean'})
  .option('package', {type: 'string'})
  .option('interface', {type: 'string'})
  .option('isCI', {type: 'boolean'})
  .option('base-api-dir', {type: 'string'})
  .option('branch-api-dir', {type: 'string'})
  .argv;

let allChanged = new Set();

// {'useSliderState' => [ 'SliderStateOptions', 'SliderState' ], ... }
let dependantOnLinks = new Map();
let depth = 0;

let allLinks = new Map();
let visited = new Set();
if (require.main === module) {
  compare().catch(err => {
    console.error(err.stack);
    process.exit(1);
  });
}

// walk up the tree and find the first package.json, then return the name
function findPackageName(filepath) {
  let parts = filepath.split(path.sep);
  for (let i = parts.length - 2; i >= 0; i--) {
    let newPath = parts.slice(0, i).join(path.sep);
    if (fs.exists(path.join(newPath, 'package.json'))) {
      return JSON.parse(fs.readFileSync(path.join(newPath, 'package.json'))).name;
    }
  }
  throw new Error('Could not find package.json for ' + filepath);
}

/**
 * This takes the json files generated by the buildBranchAPI and buildPublishedAPI and
 * reconstructs our interfaces and create a graph of all dependencies between interfaces.
 * From there, we diff the reconstructed interfaces and track all that have changes.
 * We use the graph to communicate what interfaces have changed as a result of a
 * dependency changing.
 * We build up strings of the diffs and make them easy to read in both a github comment
 * as well as the local console.
 */
export async function compare(mockRoot, mockFS, {branchAPIs, publishedAPIs} = {}) {
  if (mockFS) {
    // reset all globals if in testing mode
    fs = mockFS;
    allChanged = new Set();
    dependantOnLinks = new Map();
    depth = 0;

    allLinks = new Map();
    visited = new Set();
  }
  let branchDir = argv['branch-api-dir'] || path.join(__dirname, '..', 'dist', 'branch-api');
  let publishedDir = argv['base-api-dir'] || path.join(__dirname, '..', 'dist', 'base-api');
  if (mockFS) {
    branchDir = path.join(__dirname, '..', 'dist', 'branch');
    publishedDir = path.join(__dirname, '..', 'dist', 'base');
  }
  if (!(fs.existsSync(branchDir) && fs.existsSync(publishedDir))) {
    console.log(chalk.redBright(`you must have both a branchDir ${branchDir} and baseDir ${publishedDir}`));
    return;
  }

  if (!mockFS) {
    branchAPIs = fg.sync(`${branchDir}/**/api.json`);
    publishedAPIs = fg.sync(`${publishedDir}/**/api.json`);
  }
  let pairs = [];

  // find all matching pairs based on what's been published
  for (let pubApi of publishedAPIs) {
    // find closest package.json, use that as shared path
    let packageName = findPackageName(pubApi);
    let found = false;
    for (let branchApi of branchAPIs) {
      if (findPackageName(branchApi) === packageName) {
        found = true;
        pairs.push({pubApi, branchApi});
        break;
      }
    }
    if (!found) {
      pairs.push({pubApi, branchApi: null});
    }
  }

  // don't care about private APIs, but we do care if we're about to publish a new one
  for (let branchApi of branchAPIs) {
    let packageName = findPackageName(branchApi);
    let found = false;
    for (let pubApi of publishedAPIs) {
      if (findPackageName(pubApi) === packageName) {
        found = true;
        break;
      }
    }
    let pkgPath = path.join(branchApi, '..', '..', 'package.json');
    let json = JSON.parse(fs.readFileSync(pkgPath), 'utf8');
    if (!found && !json.private) {
      pairs.push({pubApi: null, branchApi});
    }
  }

  for (let branchApi of branchAPIs) {
    let api = JSON.parse(fs.readFileSync(branchApi), 'utf8');
    Object.entries(api.links).forEach(([key, value]) => {
      allLinks.set(key, value);
    });
  }
  for (let pubApi of publishedAPIs) {
    let api = JSON.parse(fs.readFileSync(pubApi), 'utf8');
    Object.entries(api.links).forEach(([key, value]) => {
      allLinks.set(key, value);
    });
  }

  let allDiffs = {};
  for (let pair of pairs) {
    let {diffs, name} = getDiff(pair, mockFS);
    if (diffs && diffs.length > 0) {
      allDiffs[name] = diffs;
    }
  }

  for (let [, diffs] of Object.entries(allDiffs)) {
    for (let {result: diff, simplifiedName} of diffs) {
      if (diff.length > 0) {
        if (allChanged.has(simplifiedName)) {
          console.log(simplifiedName, 'already in set');
        } else {
          allChanged.add(simplifiedName);
        }
      }
    }
  }
  let invertedDeps = invertDependencies();
  let messages = [];
  for (let [name, diffs] of Object.entries(allDiffs)) {
    let changes = [];
    for (let {result: diff, simplifiedName} of diffs) {
      let changedByDeps = followDependencies(simplifiedName);
      if (diff.length > 0) {
        let affected = followInvertedDependencies(simplifiedName, invertedDeps);
        // combine export change messages
        changes.push(`
#### ${mockFS ? simplifiedName : simplifiedName.split('packages/')[1]}
${changedByDeps.length > 0 ? `changed by:
 - ${changedByDeps.join('\n - ')}\n\n` : ''}${diff.length > 0 ? diff : ''}${affected.length > 0 ? `
it changed:
 - ${affected.join('\n - ')}
` : ''}
`);
      }
    }
    if (changes.length > 0) {
      // combine the package change messages
      messages.push(`
### ${name.replace('/dist/api.json', '').replace(/^\//, '')}
${changes.join('\n')}
-----------------------------------
`
      );
    }
  }
  if (messages.length && !mockFS) {
    messages.forEach(message => {
      console.log(message);
    });
  } else if (messages.length) {
    await mockFS.writeFile(path.join(mockRoot, 'result.txt'), messages.join('\n\n'), {});
  }
}

// takes an interface name and follows all the interfaces dependencies to
// see if the interface changed as a result of a dependency changing
function followDependencies(iname) {
  let visited = new Set();
  let changedDeps = [];
  function visit(iname) {
    if (visited.has(iname)) {
      return;
    }
    visited.add(iname);
    let dependencies = dependantOnLinks.get(iname);
    if (dependencies && dependencies.length > 0) {
      for (let dep of dependencies) {
        if (allChanged.has(dep)) {
          changedDeps.push(dep);
        }
        visit(dep);
      }
    }
  }
  visit(iname);
  return changedDeps;
}

function invertDependencies() {
  let changedUpstream = new Map();
  for (let [key, value] of dependantOnLinks.entries()) {
    for (let name of value) {
      if (changedUpstream.has(name)) {
        changedUpstream.get(name).push(key);
      } else {
        changedUpstream.set(name, [key]);
      }
    }
  }

  return changedUpstream;
}

// takes an interface name and follows all the interfaces dependencies to
// see if the interface changed as a result of a dependency changing
function followInvertedDependencies(iname, deps) {
  let visited = new Set();
  let affectedInterfaces = [];
  function visit(iname) {
    if (visited.has(iname)) {
      return;
    }
    visited.add(iname);
    if (deps.has(iname)) {
      let affected = deps.get(iname);
      if (affected && affected.length > 0) {
        for (let dep of affected) {
          affectedInterfaces.push(dep);
          visit(dep);
        }
      }
    }
  }
  visit(iname);
  return affectedInterfaces;
}

function getAPI(filePath) {
  let json = JSON.parse(fs.readFileSync(filePath), 'utf8');

  return json;
}

// bulk of the logic, read the api files, rebuild the interfaces, diff those reconstructions
function getDiff(pair, mockFS) {
  let name;
  if (pair.branchApi) {
    name = pair.branchApi.replace(/.*branch-api/, '');
  } else {
    name = pair.pubApi.replace(/.*published-api/, '');
  }

  if (argv.package && !argv.package.includes(name)) {
    return {diff: {}, name};
  }
  if (argv.verbose) {
    console.log(`diffing ${name}`);
  }
  let publishedApi = pair.pubApi === null ? {exports: {}} : getAPI(pair.pubApi);
  let branchApi = pair.branchApi === null ? {exports: {}} : getAPI(pair.branchApi);
  let publishedInterfaces = rebuildInterfaces(publishedApi);
  let branchInterfaces = rebuildInterfaces(branchApi);
  let formattedPublishedInterfaces = formatInterfaces(publishedInterfaces);
  let formattedBranchInterfaces = formatInterfaces(branchInterfaces);
  let allExportNames = new Map([...Object.entries(publishedApi.exports).map(([key, val]) => [key, val.id]), ...Object.entries(branchApi.exports).map(([key, val]) => [key, val.id])]);
  let allInterfaces = [...new Set([...Object.keys(formattedPublishedInterfaces), ...Object.keys(formattedBranchInterfaces)])];


  let diffs = [];
  allInterfaces.forEach((iname) => {
    if (argv.interface && argv.interface !== iname) {
      return;
    }
    let simplifiedName = allExportNames.get(iname);
    let codeDiff = Diff.structuredPatch(iname, iname, formattedPublishedInterfaces[iname] ?? '', formattedBranchInterfaces[iname] ?? '', {newlineIsToken: true});
    if (argv.verbose) {
      console.log(util.inspect(codeDiff, {depth: null}));
    }
    let result = [];
    let prevEnd = 1; // diff lines are 1 indexed
    let lines = (formattedPublishedInterfaces[iname] ?? '').split('\n');
    codeDiff.hunks.forEach(hunk => {
      if (hunk.oldStart > prevEnd) {
        result = [...result, ...lines.slice(prevEnd - 1, hunk.oldStart - 1).map((item, index) => ` ${item}`)];
      }
      if (argv.isCI || mockFS) {
        result = [...result, ...hunk.lines];
      } else {
        result = [...result, ...hunk.lines.map(line => {
          if (line.startsWith('+')) {
            return chalk.whiteBright.bgGreen(line);
          } else if (line.startsWith('-')) {
            return chalk.whiteBright.bgRed(line);
          }
          return line;
        })];
      }
      prevEnd = hunk.oldStart + hunk.oldLines;
    });
    let joinedResult = '';
    if (codeDiff.hunks.length > 0) {
      joinedResult = [...result, ...lines.slice(prevEnd).map((item, index) => ` ${item}`)].join('\n');
    }
    joinedResult = joinedResult.replace(/\n.*No newline at end of file/, '');

    if (argv.isCI && result.length > 0) {
      joinedResult = `\`\`\`diff
${joinedResult}
\`\`\``;
    }
    diffs.push({iname, result: joinedResult, simplifiedName});
  });

  return {diffs, name};
}

function processType(value) {
  let processed = visited.has(value);
  if (processed) {
    return '';
  }
  visited.add(value);
  let val = _processType(value);
  visited.delete(value);
  return val;
}

// mirrors dev/docs/src/types.js for the most part
// "rendering" our types to a string instead of React components
function _processType(value) {
  if (!value) {
    console.trace('UNTYPED', value);
    return 'UNTYPED';
  }

  if (Object.keys(value).length === 0) {
    return '{}';
  }
  if (value.type === 'any') {
    return 'any';
  }
  if (value.type === 'null') {
    return 'null';
  }
  if (value.type === 'undefined') {
    return 'undefined';
  }
  if (value.type === 'void') {
    return 'void';
  }
  if (value.type === 'unknown') {
    return 'unknown';
  }
  if (value.type === 'never') {
    return 'never';
  }
  if (value.type === 'this') {
    return 'this';
  }
  if (value.type === 'symbol') {
    return 'symbol';
  }
  if (value.type === 'identifier') {
    return value.name;
  }
  if (value.type === 'string') {
    if (value.value) {
      return `'${value.value}'`;
    }
    return 'string';
  }
  if (value.type === 'number') {
    return 'number';
  }
  if (value.type === 'boolean') {
    return 'boolean';
  }
  if (value.type === 'union') {
    return value.elements.map(processType).join(' | ');
  }
  if (value.type === 'intersection') {
    return `(${value.types.map(processType).join(' & ')})`;
  }
  if (value.type === 'application') {
    let name = value.base.name;
    if (!name) {
      name = processType(value.base);
    }
    return `${name}<${value.typeParameters.map(processType).join(', ')}>`;
  }
  if (value.type === 'typeOperator') {
    return `${value.operator} ${processType(value.value)}`;
  }
  if (value.type === 'function') {
    return `(${value.parameters.map(processType).join(', ')}) => ${value.return ? processType(value.return) : 'void'}`;
  }
  if (value.type === 'parameter') {
    return processType(value.value);
  }
  if (value.type === 'link' && value.id) {
    let type = allLinks.get(value.id);
    if (!type) {
      console.log(value.id, type);
    }
    return allLinks.get(value.id).name;
  }
  if (value.type === 'interface') {
    return `
interface ${value.name}${value.extends ? ` extends ${value.extends.map(processType).join(', ')}` : ''} {
  ${Object.values(value.properties).filter(property => property.access !== 'private' && property.access !== 'protected').map(property => {
    depth += 2;
    let result = ' '.repeat(depth);
    result = `${result}${property.indexType ? '[' : ''}${property.name}${property.indexType ? `: ${processType(property.indexType)}]` : ''}${property.optional ? '?' : ''}: ${processType(property.value)}`;
    depth -= 2;
    return result;
  }).join('\n')}
}
`;
  }
  // interface still needed if we have it at top level?
  if (value.type === 'object') {
    if (value.properties) {
      depth += 2;
      let result = `${value.exact ? '{\\' : '{'}
  ${Object.values(value.properties).map(property => {
    let result = ' '.repeat(depth);
    result = `${result}${property.indexType ? '[' : ''}${property.name}${property.indexType ? `: ${processType(property.indexType)}]` : ''}${property.optional ? '?' : ''}: ${processType(property.value)}`;
    return result;
  }).join('\n')}
${value.exact ? '\\}' : `${' '.repeat(depth)}}`}`;
      depth -= 2;
      return result;
    }
    return '{}';
  }
  if (value.type === 'alias') {
    return processType(value.value);
  }
  if (value.type === 'array') {
    return `Array<${processType(value.elementType)}>`;
  }
  if (value.type === 'tuple') {
    return `[${value.elements.map(processType).join(', ')}]`;
  }
  if (value.type === 'typeParameter') {
    let typeParam = value.name;
    if (value.constraint) {
      typeParam = typeParam + ` extends ${processType(value.constraint)}`;
    }
    if (value.default) {
      typeParam = typeParam + ` = ${processType(value.default)}`;
    }
    return typeParam;
  }
  if (value.type === 'component') {
    let props = value.props;
    if (props.type === 'application') {
      props = props.base;
    }
    if (props.type === 'link') {
      // create links provider
      // props = links[props.id];
    }
    return processType(props);
  }
  if (value.type === 'conditional') {
    return `${processType(value.checkType)} extends ${processType(value.extendsType)} ? ${processType(value.trueType)}${value.falseType.type === 'conditional' ? ' :\n' : ' : '}${processType(value.falseType)}`;
  }
  if (value.type === 'indexedAccess') {
    return `${processType(value.objectType)}[${processType(value.indexType)}]`;
  }
  if (value.type === 'keyof') {
    return `keyof ${processType(value.keyof)}`;
  }
  if (value.type === 'variable') {
    return `${value.name}: ${processType(value.typeAnnotation)}`;
  }
  console.log('unknown type', value);
  return 'unknown type';
}

function rebuildInterfaces(json) {
  let exports = {};
  if (!json.exports) {
    return exports;
  }

  Object.keys(json.exports).forEach((key) => {
    let item = json.exports[key];
    if (item?.type == null) {
      // todo what to do here??
      return;
    }
    if (item.props?.type === 'identifier') {
      // todo what to do here??
      return;
    }
    if (item.type === 'component') {
      let compInterface = {};
      if (item.props && item.props.properties) {
        Object.entries(item.props.properties).sort((([keyA], [keyB]) => keyA > keyB ? 1 : -1)).forEach(([, prop]) => {
          if (prop.access === 'private') {
            return;
          }
          let name = prop.name;
          if (item.name === null) {
            name = key;
          }
          let optional = prop.optional;
          let defaultVal = prop.default;
          let value = processType(prop.value);
          compInterface[name] = {optional, defaultVal, value};
        });
      } else if (item.props && item.props.type === 'link') {
        let prop = item.props;
        let name = item.name;
        if (item.name === null) {
          name = key;
        }
        let optional = prop.optional;
        let defaultVal = prop.default;
        let value = processType(prop);
        compInterface[name] = {optional, defaultVal, value};
      }
      let name = item.name ?? key;
      if (item.typeParameters.length > 0) {
        name = name + `<${item.typeParameters.map(processType).join(', ')}>`;
      }
      exports[key] = {[name]: compInterface};
    } else if (item.type === 'function') {
      let funcInterface = {};
      Object.entries(item.parameters).forEach(([, param]) => {
        if (param.access === 'private') {
          return;
        }
        let name = param.name;
        let optional = param.optional;
        let defaultVal = param.default;
        let value = processType(param.value);
        funcInterface[name] = {optional, defaultVal, value};
      });
      let returnVal = processType(item.return);
      let name = item.name ?? key;
      if (item.typeParameters.length > 0) {
        name = name + `<${item.typeParameters.map(processType).join(', ')}>`;
      }
      exports[key] = {[name]: {...funcInterface, returnVal}};
    } else if (item.type === 'interface') {
      let funcInterface = {};
      Object.entries(item.properties).sort((([keyA], [keyB]) => keyA > keyB ? 1 : -1)).forEach(([, property]) => {
        if (property.access === 'private' || property.access === 'protected') {
          return;
        }
        let name = property.name;
        let optional = property.optional;
        let defaultVal = property.default;
        let value;
        if (property.value) {
          if (property.value.type === 'link' && !property.value.id) {
            console.log(item)
          }
          value = processType(property.value);
        }
        // TODO: what to do with defaultVal and optional
        funcInterface[name] = {optional, defaultVal, value};
      });
      let name = item.name ?? key;
      if (item.typeParameters.length > 0) {
        name = name + `<${item.typeParameters.map(processType).join(', ')}>`;
      }
      if (item.extends?.length > 0) {
        name = name + ` extends ${item.extends.map(processType).join(', ')}`;
      }
      exports[key] = {[name]: funcInterface};
    } else if (item.type === 'link') {
      let links = json.links;
      if (links[item.id]) {
        let link = links[item.id];

        let name = link.name;
        let optional = link.optional;
        let defaultVal = link.default;
        let value = processType(link.value);
        exports[key] = {[name]: {kind: 'type', optional, defaultVal, value}};
      }
    } else {
      let identifier = item;
      let value = processType(identifier);
      exports[key] = {[key]: {kind: 'identifier', value}};
    }
  });
  return exports;
}

function formatProp([name, prop]) {
  if (name === 'returnVal') {
    return `${name}: ${prop}`;
  }
  return `${name}${prop.optional ? '?' : ''}: ${prop.value}${prop.defaultVal != null ? ` = ${prop.defaultVal}` : ''}`;
}

function formatInterfaces(interfaces) {
  let result = {};
  Object.entries(interfaces).forEach(([id, value]) => {
    let [name, val] = Object.entries(value)[0];
    let output = '';
    if (val.kind === 'type') {
      output = `${name} {\n`;
      depth += 2;
      output += `${' '.repeat(depth)}${formatProp(name, val)}`;
      depth -= 2;
      result[id] = `${output}${' '.repeat(depth)}}\n`;
    } else if (val.kind === 'identifier') {
      output = val.value;
      result[id] = `${output}\n`;
    } else {
      output = `${name} {\n`;
      depth += 2;
      output += Object.entries(val).map(formatProp).map((prop) => `${' '.repeat(depth)}${prop}\n`).join('');
      depth -= 2;
      result[id] = `${output}${' '.repeat(depth)}}\n`;
    }
  });
  return result;
}
