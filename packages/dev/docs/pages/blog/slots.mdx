<!-- Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License. -->


import {BlogPostLayout} from '@react-spectrum/docs';
export default BlogPostLayout;

---
keywords: [react spectrum, react, spectrum, context]
description: There are many ways of creating composable React components, this is our take on a flexible way that allows us to enforce certain properties.
date: 2021-07-19
author: '[Rob Snow](https://twitter.com/snowystinger)'
image: ../assets/ReactAria_976x445_2x.png
---

# Creating flexible composable components

Building components in React frequently involves combining or composing many other components. We want this to be intuitive and to "just work". We also want it to be flexible for customization where appropriate but be able to lock in certain features so that users can't accidentally shoot themselves in the foot.

## What do we want

As with most coding problems, we start with how do we want out API to look.
```snippet
<Dialog>
  <Title>The dialogs title</Title>
  <Header>Extra heading level content</Header>
  <Body>This is the content of the dialog.</Body>
  <Footer>This is the dialogs footer</Footer>
  <ButtonGroup>
    <Button>Cancel</Button>
    <Button>Confirm</Button>
  </ButtonGroup>
</Dialog>
```
This was the simplest representation of a Dialog we could come up with for our Design System. I've lifted the names straight from the Design specs for the different areas that content can reside in as seen here. <!-- TODO GET IMAGE --> Now you may be looking at this and saying that it looks pretty similar to how our library works. So spoilers, we accomplished our goal. However, I think it can be valuable to look at the other options we considered in order to get here, this way, the pros and cons will have some context (no pun intended).

## Problems of passing props in React

In React, we frequently want to have components that act as containers for other components. When the container does not care about the children, this is easy. But sometimes the container expects certain components as children or expects that the children have certain props set on them. This can be a difficult problem to solve in React.

### React cloneChildren

The first tool you may be tempted to reach for is React's [cloneChildren](https://reactjs.org/docs/react-api.html#cloneelement). This is a powerful function that allows a component to take any children passed to it and modify what props are passed to them (not strictly how it works, but it gets the idea across). For instance, maybe you have a `List` of selectable `Option`s, and you want to add a callback to each of those so that `List` can track with `Option` is currently selected. You could make a `List` component that looks something like this.

```snippet
function List(props) {
  let [selected, setSelected] = useState(props.defaultSelected);
  return React.Children.map(this.props.children, child => {
     return React.cloneElement(child, {
       onSelect: (value) => setSelected(value)
     });
  });
}

<List>
  <Option>One</Option>
  <Option>Two</Option>
  <Option>Three</Option>
</List>
```

Great, we have a `List` and we can pass arbitrary `Option`s to it. Well, almost. We can pass any React Element that can take an `onSelect` prop that matches the signature `(value:string) => void`. What if we wanted to wrap some of our `Option`s in a component that performed some analytics.

```snippet
<List>
  <Analytics><Option>One</Option></Analytics>
  <Option>Two</Option>
  <Option>Three</Option>
</List>
```

Well, we'd need to pass `onSelect` through the Analytics wrapping component down to the Option. This can get pretty messy pretty quickly, maybe the options also need classnames, keyboard handlers, etc, it can get hard to follow the props and make sure all the right ones are passed through.

Or, what if we had something like the `Dialog` example where the children could be different elements. You would need something like:

```snippet
function Dialog(props) {
  let index = 0;
  return React.Children.map(this.props.children, child => {
    let childProps = {};
    if (index === 0) {/* ... add props to childProps for Title */}
    else if (index === 1) {/* ... add props to childProps for Heading */}
    // ... etc
    index++;
    return React.cloneElement(child, childProps);
  });
}
```

This is also restricted to the order in which the children are added, and if you tried to inspect the children to find out which was which, you'd ruin the ability to add a component like our `Analytics` above.

### Render Props

There is another way to handle this without looping over children, called [Render Props](https://reactjs.org/docs/render-props.html). In this, we could expose the `children` prop as a function that accepts a number of props. Maybe something like this

```snippet
function Dialog(props) {
  return props.children({title: {id, classname}, body: {/* body props ...etc */})
}
```

Which we could use like:

```snippet
<Dialog>
  {({title, body}) => (
    <Title {...title} />
    <Heading />
    <Analytics><Body {...body} /></Analytics>
    ...
  )}
</Dialog>
```

This solves our issue that we couldn't wrap the elements in other components. It has also taken care of needing to know the order of the children and we no longer need to clone them to apply props. Instead, we've put some boilerplate burden on users, as they now have to attach the right arguments to the right elements. This is most obvious in our `List` example. To make a static list, you'd need to do something like:

```snippet
<List>
  {(optionProps) => (
    <>
      <Analytics><Option {...optionProps}>One</Option></Analytics>
      <Option {...optionProps}>Two</Option>
      <Option {...optionProps}>Three</Option>
    </>
  )}
</List>
```

That is a lot of repeating the same spread, plus the React Fragment is annoying to remember.
It also makes documentation harder because children are such a special prop and this deviates from the expected usage. Users can also get into trouble if they decide they know better than the Design System because they could intentionally omit props very easily or change the order of the children and swap the props they apply.

We could make it harder to do this by employing multiple Render Props

```snippet
<Dialog title={(title) => <Title {...title} />} body={(body) => <Analytics><Body {...body} /></Analytics>} />
```

Now the props can't be swapped around as easily, but it's at the cost of making the component much harder to read because the JSX is disrupted by props everywhere. In addition, this makes the `List` even harder and you don't want to mix the two styles because that's confusing to users.


### Context

<!-- TODO better transitions in this entire section -->
Fortunately there is another method of passing information to child components that doesn't expose the information to a user and it doesn't matter how many components are placed in between the parent and the child, [Context](https://reactjs.org/docs/context.html). Typically Context is used for global values, like themes, or between two very specific components. An example of what I mean by very specific might've been something like this:

```snippet
<Dialog>
  <Dialog.Title>The dialogs title</Dialog.Title>
  <Dialog.Header>Extra heading level content</Dialog.Header>
  <Dialog.Body>This is the content of the dialog.</Dialog.Body>
  ...
</Dialog>
```
Where Dialog has a DialogContext and the Dialog child components know about this context. However, we wanted to avoid this situation where we have special child components for every component. It adds a lot of bloat to our library and doesn't add much functionality.

We strike a deliberate middle ground between global and specific components. We have classes of components, containers or parent components, and children. For example, Dialogs are a container and Title, Body, etc are children. Because we wanted to avoid components like the above mentioned `Dialog.Title`, we came up with some different component names than the original blueprint for Dialog showed. For example, Body doesn't make much sense in the context of a List Option (another container), so we opted for `Content`. From our exploration of Render Props and looking at web component api's, we borrowed the term [Slots](https://react-spectrum.adobe.com/react-spectrum/layout.html#slots). Next we needed rules for Slots to follow:
 1. Containers can have many named slots and children consume a single slot each
 1. Children consuming Slots must have a default slot
 1. Children consuming Slots can have another slot name defined
 1. Multiple children can consume the same slot
 1. We only pass props on the Slots Context
 1. Props passed on the Slots Context should have priority over user provided props, except style/classname/id

The most important rule and the one that took us longest to realize is the last one. As we began using Slots, we realized that if a container passed a prop to a particular slot, then the container knew best, or parent knows best. For example, in our Dialog layout, we know that we will only ever use the medium size of `Divider` to go between the Header and Body areas. We wanted to make sure that a user couldn't specify `large` or `small` variants of the `Divider`. In the case of styles and classnames though, we merge, though Slots still win in duplicate style keys. Finally, we decided that a user provided id should always win so that they can target their elements in the way they expect.

Using Context can be dangerous though, there's no stopping it (<!-- todo get image you can't stop the signal mal -->). So we purposefully clear our Slots Context in cases where we expect the user to supply a lot of content that may contain anything. <!-- todo example dialog with a vertical divider in the content region -->

The Slots Context also lent itself very nicely to our move to use Flex and Grid. If all slotted elements are provided as siblings to the parent, then we don't need to worry about the order in which they are added. We can set the CSS `order` or `grid-area` and they'll always appear in the correct place.


## Conclusion

Slots Context can be a great way to build composable components in a Design System or Application. I'm not saying to use Slots for everything, both cloneElement and Render Props have their places and we've used both of them. Instead, Slots can help facilitate component generalization and enforce layout and behavior choices within a container.
