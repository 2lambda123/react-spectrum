{/* Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License. */}

import {Layout} from '@react-spectrum/docs';
export default Layout;

import docs from 'docs:react-aria-components';
import collectionsDocs from 'docs:@react-types/shared/src/collections.d.ts';
import {PropTable, FunctionAPI, HeaderInfo, InterfaceType, TypeContext, TypeLink, PageDescription, StateTable} from '@react-spectrum/docs';
import i18nDocs from 'docs:@react-aria/i18n';
import listboxDocs from 'docs:@react-aria/listbox';
import overlaysDocs from 'docs:@react-aria/overlays';
import packageData from 'react-aria-components/package.json';
import selectionDocs from 'docs:@react-stately/selection';
import statelyDocs from 'docs:@react-stately/combobox';
import Anatomy from '/packages/@react-aria/combobox/docs/anatomy.svg';
import ChevronRight from '@spectrum-icons/workflow/ChevronRight';
import {ExampleCard} from '@react-spectrum/docs/src/ExampleCard';
import {Divider} from '@react-spectrum/divider';

---
category: Pickers
keywords: [combobox, autocomplete, autosuggest, typeahead, search, aria]
type: component
---

# ComboBox

<PageDescription>{docs.exports.ComboBox.description}</PageDescription>

<HeaderInfo
  packageData={packageData}
  componentNames={['ComboBox']}
  sourceData={[
    {type: 'W3C', url: 'https://www.w3.org/WAI/ARIA/apg/patterns/combobox/'}
  ]} />

[Hooks](useComboBox.html) • [Component](ComboBox.html)

## Example

```tsx example
import {ComboBox, Label, Input, Button, Popover, ListBox, Item} from 'react-aria-components';

<ComboBox>
  <Label>Test</Label>
  <div>
    <Input />
    <Button>▼</Button>
  </div>
  <Popover>
    <ListBox>
      <Item>Foo</Item>
      <Item>Bar</Item>
      <Item>Baz</Item>
    </ListBox>
  </Popover>
</ComboBox>
```

<details>
  <summary style={{fontWeight: 'bold'}}><ChevronRight size="S" /> Show CSS</summary>

```css
[role=listbox] {
  display: block;
  min-width: 150px;
  width: fit-content;
  margin: 4px 0 0 0;
  border: 1px solid gray;
  background: lightgray;
  padding: 0;
  list-style: none;
}

[role=option] {
  padding: 2px 5px;
  outline: none;
  cursor: default;
  color: black;
  background: transparent;
}

[role=option][data-focused] {
  background: gray;
  color: white;
}

[role=option][aria-selected=true] {
  background: purple;
  color: white;
}
```

</details>

## Anatomy

<Anatomy />

A combo box consists of a label, an input which displays the current value, a list box popup, and an optional button
used to toggle the list box popup open state. Users can type within the input to filter the available options
within the list box. The list box popup may be opened by a variety of input field interactions specified
by the `menuTrigger` prop provided to `ComboBox`, or by clicking or touching the button.

### Concepts

`ComboBox` makes use of the following concepts:

* [Collections](../react-stately/Collections.html)
* [Selection](../react-stately/Selection.html)

### Composed components

A `ComboBox` uses the following components, which may also be used standalone or reused in other components.

* [Label](useLabel.html)
* [Input](Input.html)
* [Button](useButton.html)
* [Popover](useOverlay.html)
* [ListBox](useListBox.html)

### Hooks

For more customization options, React Aria hooks can be used to replace any of the components used in a `ComboBox`.

* [useComboBox](useComboBox.html)

## Props

### ComboBox

<PropTable component={docs.exports.ComboBox} links={docs.links} />

<Divider UNSAFE_style={{margin: '20px 0'}} />

### ListBox

<PropTable component={docs.exports.ListBox} links={docs.links} />

<Divider size="M" UNSAFE_style={{margin: '20px 0'}} />

<details>
  <summary style={{fontWeight: 'bold'}}><ChevronRight size="S" />

### Item

</summary>

<PropTable component={docs.exports.Item} links={docs.links} />

</details>

## Styling

All React Aria components accept the `className` and `style` DOM attributes for styling. These can be used to implement styling with custom CSS classes, inline styles, utility CSS classes (e.g. Tailwind), CSS-in-JS libraries (e.g. Styled Components), etc.

```jsx
<ListBox className="listbox">
  {/* ... */}
</ListBox>
```

Many components also use the ARIA `role` attribute, which can also be used in CSS selectors to target elements of a certain type without the need for custom class names. These are documented below.

```css
[role=listbox] {
  /* ... */
}
```

In addition, some components support multiple UI states (e.g. pressed, hovered, etc.). React Aria components expose states using DOM attributes, which you can target in CSS selectors. These are ARIA attributes wherever possible, or data attributes when a relevant ARIA attribute does not exist. For example:

```css
.item[aria-selected=true] {
  /* ... */
}

.item[data-focused] {
  /* ... */
}
```

The `className` and `style` props also accept functions which receive states for styling. This lets you dynamically determine the classes or styles to apply, which is useful when using utility CSS libraries like [Tailwind](https://tailwindcss.com/).

```jsx
<Item className={({isSelected}) => isSelected ? 'bg-blue-400' : 'bg-gray-100'}>
  Item
</Item>
```

The states and selectors for each component used in a `ComboBox` are documented below.

### ComboBox

The `ComboBox` component itself does not render any DOM elements (it only passes through its children) so it does not support styling. If you need a wrapper element, add one yourself inside the `<ComboBox>`.

```jsx
<ComboBox>
  <div className="my-combobox">
    {/* ... */}
  </div>
</ComboBox>
```

### Label

A `Label` can be targeted with the `label` CSS selector, or by adding a custom `className`.

### Input

An `Input` can be targeted with the `input` CSS selector, or by adding a custom `className`. It supports standard CSS pseudo classes such as `:focus` for states. See [MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes#user_action_pseudo-classes) for details.

### Popover

The `Popover` component can be targeted with a custom `className`. Note that it renders in a [React Portal](https://reactjs.org/docs/portals.html), so it will not appear as a descendant of the ComboBox in the DOM.

### ListBox

A `ListBox` can be targeted with the `[role=listbox]` CSS selector, or by adding a custom `className`.

### Item

An `Item` can be targeted with the `[role=option]` CSS selector, or by adding a custom `className`. It supports the following states:

<StateTable properties={docs.exports.ItemStates.properties} />

### Button

A `Button` can be targeted with the `button` CSS selector, or by adding a custom `className`. It supports the following states:

<StateTable properties={docs.exports.ButtonRenderProps.properties} />

## Making it reusable

```tsx example export=true
import clsx from 'clsx';

function MyComboBox({label, children, ...props}) {
  return (
    <ComboBox {...props}>
      <Label>{label}</Label>
      <div>
        <Input />
        <Button>▼</Button>
      </div>
      <Popover>
        <ListBox className="menu">
          {children}
        </ListBox>
      </Popover>
    </ComboBox>
  );
}

function MyItem(props) {
  return <Item {...props} className={({isFocused, isSelected}) => clsx('item', {focused: isFocused, selected: isSelected})} />
}

<MyComboBox label="Test">
  <MyItem>Foo</MyItem>
  <MyItem>Bar</MyItem>
  <MyItem>Baz</MyItem>
</MyComboBox>
```

## Usage

### Dynamic collections

ComboBox follows the [Collection Components API](../react-stately/collections.html), accepting both static and dynamic collections.
The examples above show static collections, which can be used when the full list of options is known ahead of time. Dynamic collections,
as shown below, can be used when the options come from an external data source such as an API call, or update over time.

As seen below, an iterable list of options is passed to the ComboBox using the `defaultItems` prop. Each item accepts a `key` prop, which
is passed to the `onSelectionChange` handler to identify the selected item. Alternatively, if the item objects contain an `id` property,
as shown in the example below, then this is used automatically and a `key` prop is not required.

```tsx example
function Example() {
  let options = [
    {id: 1, name: 'Aerospace'},
    {id: 2, name: 'Mechanical'},
    {id: 3, name: 'Civil'},
    {id: 4, name: 'Biomedical'},
    {id: 5, name: 'Nuclear'},
    {id: 6, name: 'Industrial'},
    {id: 7, name: 'Chemical'},
    {id: 8, name: 'Agricultural'},
    {id: 9, name: 'Electrical'}
  ];
  let [majorId, setMajorId] = React.useState();

  return (
    <>
      <MyComboBox defaultItems={options} onSelectionChange={setMajorId}>
        {(item) => <MyItem>{item.name}</MyItem>}
      </MyComboBox>
      <p>Selected topic id: {majorId}</p>
    </>
  );
}
```

## Advanced customization

### Composition

If you need to customize one of the components within a `ComboBox`, such as `Input` or `ListBox`, in many cases you can create a wrapper
component. This lets you customize the props passed to the component.

```tsx
function MyListBox(props) {
  return <ListBox {...props} className="my-listbox" />
}
```

### Hooks

If you need to customize things even further, such as accessing internal state or customizing DOM structure, you can drop down to the lower
level Hook-based API. `ComboBox` sends props to its child elements via public React contexts for each component. You can use this context to
implement replacements for any component, using hooks from `react-aria`. This allows you to replace only the components you need to customize,
and keep using the others.

```tsx
import {ListBoxContext} from 'react-aria-components';
import {useListBox, mergeProps} from 'react-aria';

function MyListBox(props) {
  let {state, ...context} = useContext(ListBoxContext);
  props = mergeProps(props, context);

  let {listBoxProps} = useListBox(props, state, ref);

  // ...
}
```

This also works the other way. If you need to customize `ComboBox` itself, but want to reuse the components it contains, you can do so by providing
the necessary contexts.

```tsx
import {useComboBox, LabelContext, ButtonContext, InputContext, PopoverContext, ListBoxContext} from 'react-aria';

function MyComboBox(props) {
  // ...
  let {
    buttonProps,
    inputProps,
    listBoxProps,
    labelProps
  } = useComboBox({ /* ... */ });


}
```
