{/* Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License. */}

import {Layout} from '@react-spectrum/docs';
export default Layout;

import docs from 'docs:react-aria-components';
import collectionsDocs from 'docs:@react-types/shared/src/collections.d.ts';
import {PropTable, FunctionAPI, HeaderInfo, InterfaceType, TypeContext, TypeLink, PageDescription} from '@react-spectrum/docs';
import i18nDocs from 'docs:@react-aria/i18n';
import listboxDocs from 'docs:@react-aria/listbox';
import overlaysDocs from 'docs:@react-aria/overlays';
import packageData from 'react-aria-components/package.json';
import selectionDocs from 'docs:@react-stately/selection';
import statelyDocs from 'docs:@react-stately/combobox';
import Anatomy from '/packages/@react-aria/combobox/docs/anatomy.svg';
import ChevronRight from '@spectrum-icons/workflow/ChevronRight';
import {ExampleCard} from '@react-spectrum/docs/src/ExampleCard';

---
category: Pickers
keywords: [combobox, autocomplete, autosuggest, typeahead, search, aria]
type: component
---

# ComboBox

<PageDescription>{docs.exports.ComboBox.description}</PageDescription>

<HeaderInfo
  packageData={packageData}
  componentNames={['ComboBox']}
  sourceData={[
    {type: 'W3C', url: 'https://www.w3.org/WAI/ARIA/apg/patterns/combobox/'}
  ]} />

[Hooks](useComboBox.html) • [Component](ComboBox.html)

## Example

```tsx example
import {ComboBox, Label, Input, Button, Popover, ListBox, Item} from 'react-aria-components';

<ComboBox>
  <Label>Test</Label>
  <div>
    <Input />
    <Button>▼</Button>
  </div>
  <Popover>
    <ListBox>
      <Item>Foo</Item>
      <Item>Bar</Item>
      <Item>Baz</Item>
    </ListBox>
  </Popover>
</ComboBox>
```

```css
[role=listbox] {
  display: block;
  min-width: 150px;
  width: fit-content;
  margin: 4px 0 0 0;
  border: 1px solid gray;
  background: lightgray;
  padding: 0;
  list-style: none;
}

[role=option] {
  padding: 2px 5px;
  outline: none;
  cursor: default;
  color: black;
  background: transparent;
}

[role=option][data-focused] {
  background: gray;
  color: white;
}

[role=option][aria-selected=true] {
  background: purple;
  color: white;
}
```

## Anatomy

<Anatomy />

A combo box consists of a label, an input which displays the current value, a list box popup, and an optional button
used to toggle the list box popup open state. Users can type within the input to filter the available options
within the list box. The list box popup may be opened by a variety of input field interactions specified
by the `menuTrigger` prop provided to `ComboBox`, or by clicking or touching the button.

### Concepts

`ComboBox` makes use of the following concepts:

* [Collections](../react-stately/Collections.html)
* [Selection](../react-stately/Selection.html)

### Composed components

A `ComboBox` uses the following components, which may also be used standalone or reused in other components.

* [Label](useLabel.html)
* [Input](Input.html)
* [Button](useButton.html)
* [Popover](useOverlay.html)
* [ListBox](useListBox.html)

### Hooks

For more customization options, React Aria hooks can be used to replace any of the components used in a `ComboBox`.

* [useComboBox](useComboBox.html)

## Making it reusable

```tsx example export=true
import clsx from 'clsx';

function MyComboBox({label, children, ...props}) {
  return (
    <ComboBox {...props}>
      <Label>{label}</Label>
      <div>
        <Input />
        <Button>▼</Button>
      </div>
      <Popover>
        <ListBox className="menu">
          {children}
        </ListBox>
      </Popover>
    </ComboBox>
  );
}

function MyItem(props) {
  return <Item {...props} className={({isFocused, isSelected}) => clsx('item', {focused: isFocused, selected: isSelected})} />
}

<MyComboBox label="Test">
  <MyItem>Foo</MyItem>
  <MyItem>Bar</MyItem>
  <MyItem>Baz</MyItem>
</MyComboBox>
```

## Props

### ComboBox

<PropTable component={docs.exports.ComboBox} links={docs.links} />

### ListBox

<PropTable component={docs.exports.ListBox} links={docs.links} />

### Item

<PropTable component={docs.exports.Item} links={docs.links} />

## Styling

### DOM attributes

`Item` elements expose the following attributes on their DOM nodes, which can be used for styling:

* `[data-focused]` – Whether the item is currently focused, either by hovering or keyboard.
* `[data-pressed]` – Whether the item is currently in a pressed state.
* `[aria-selected=true]` – Whether the item is selected.
* `[aria-disabled]` – Whether the item is disabled.

It using CSS, you can either target `[role=option]`, or add a custom `className` to `<Item>`.

```css
.item {
  /* ... */
}

.item[aria-selected=true] {
  /* ... */
}
```

If using a CSS-in-JS such as Styled Components, you can wrap `Item` in order to style it:

```jsx
const MyItem = styled(Item)`
  /* ... */

  &[aria-selected=true] {
    /* ... */
  }
`;
```

### Render props

The `className` and `style` props also accept functions which receive states for styling. This lets you dynamically determine the classes or styles to apply, which is useful when using utility CSS libraries like Tailwind.

```jsx
<Item className={({isSelected}) => isSelected ? 'bg-blue-400' : 'bg-gray-100'}>Item</Item>
```

The following states are passed to render props functions:

<TypeContext.Provider value={docs.links}>
  <InterfaceType properties={docs.exports.ItemStates.properties} hideType />
</TypeContext.Provider>

## Usage

### Dynamic collections

ComboBox follows the [Collection Components API](../react-stately/collections.html), accepting both static and dynamic collections.
The examples above show static collections, which can be used when the full list of options is known ahead of time. Dynamic collections,
as shown below, can be used when the options come from an external data source such as an API call, or update over time.

As seen below, an iterable list of options is passed to the ComboBox using the `defaultItems` prop. Each item accepts a `key` prop, which
is passed to the `onSelectionChange` handler to identify the selected item. Alternatively, if the item objects contain an `id` property,
as shown in the example below, then this is used automatically and a `key` prop is not required.

```tsx example
function Example() {
  let options = [
    {id: 1, name: 'Aerospace'},
    {id: 2, name: 'Mechanical'},
    {id: 3, name: 'Civil'},
    {id: 4, name: 'Biomedical'},
    {id: 5, name: 'Nuclear'},
    {id: 6, name: 'Industrial'},
    {id: 7, name: 'Chemical'},
    {id: 8, name: 'Agricultural'},
    {id: 9, name: 'Electrical'}
  ];
  let [majorId, setMajorId] = React.useState();

  return (
    <>
      <MyComboBox defaultItems={options} onSelectionChange={setMajorId}>
        {(item) => <MyItem>{item.name}</MyItem>}
      </MyComboBox>
      <p>Selected topic id: {majorId}</p>
    </>
  );
}
```

## Advanced customization

### Composition

If you need to customize one of the components within a `ComboBox`, such as `Input` or `ListBox`, in many cases you can create a wrapper
component. This lets you customize the props passed to the component.

```tsx
function MyListBox(props) {
  return <ListBox {...props} className="my-listbox" />
}
```

### Hooks

If you need to customize things even further, such as accessing internal state or customizing DOM structure, you can drop down to the lower
level Hook-based API. `ComboBox` sends props to its child elements via public React contexts for each component. You can use this context to
implement replacements for any component, using hooks from `react-aria`. This allows you to replace only the components you need to customize,
and keep using the others.

```tsx
import {ListBoxContext} from 'react-aria-components';
import {useListBox, mergeProps} from 'react-aria';

function MyListBox(props) {
  let {state, ...context} = useContext(ListBoxContext);
  props = mergeProps(props, context);

  let {listBoxProps} = useListBox(props, state, ref);

  // ...
}
```

This also works the other way. If you need to customize `ComboBox` itself, but want to reuse the components it contains, you can do so by providing
the necessary contexts.

```tsx
import {useComboBox, LabelContext, ButtonContext, InputContext, PopoverContext, ListBoxContext} from 'react-aria';

function MyComboBox(props) {
  // ...
  let {
    buttonProps,
    inputProps,
    listBoxProps,
    labelProps
  } = useComboBox({ /* ... */ });


}
```
