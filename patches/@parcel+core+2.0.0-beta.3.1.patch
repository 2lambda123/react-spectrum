diff --git a/node_modules/@parcel/core/lib/BundleGraph.js b/node_modules/@parcel/core/lib/BundleGraph.js
index 3c0dc1a..ab47d8c 100644
--- a/node_modules/@parcel/core/lib/BundleGraph.js
+++ b/node_modules/@parcel/core/lib/BundleGraph.js
@@ -393,7 +393,10 @@ class BundleGraph {
         return;
       }
 
-      if (this._graph.hasEdge(bundleNodeId, nodeId, 'contains')) {
+      if (
+        this._graph.hasEdge(bundleNodeId, nodeId, 'contains') &&
+        (node.type !== 'asset' || this.isAssetReachableFromBundle(node.value, bundle))
+      ) {
         this._graph.removeEdge(bundleNodeId, nodeId, 'contains', // Removing this contains edge should not orphan the connected node. This
         // is disabled for performance reasons as these edges are removed as part
         // of a traversal, and checking for orphans becomes quite expensive in
@@ -407,6 +410,7 @@ class BundleGraph {
         }
       } else {
         actions.skipChildren();
+        return;
       }
 
       if (node.type === 'asset' && this._graph.hasEdge(bundleNodeId, nodeId)) {
@@ -690,7 +694,6 @@ class BundleGraph {
 
       let parentBundleNodes = this._graph.getNodeIdsConnectedTo(this._graph.getNodeIdByContentKey((0, _utils2().getBundleGroupId)(bundleGroup)), 'bundle'); // Check that every parent bundle has a bundle group in its ancestry that contains the asset.
 
-
       return parentBundleNodes.every(bundleNodeId => {
         let bundleNode = (0, _nullthrows().default)(this._graph.getNode(bundleNodeId));
 
@@ -787,7 +790,7 @@ class BundleGraph {
           }
         }
 
-        actions.skipChildren();
+        // actions.skipChildren();
       }, visit),
       startNodeId: bundleNodeId,
       getChildren: nodeId => {
diff --git a/node_modules/@parcel/core/lib/RequestTracker.js b/node_modules/@parcel/core/lib/RequestTracker.js
index de634cd..44dd5c9 100644
--- a/node_modules/@parcel/core/lib/RequestTracker.js
+++ b/node_modules/@parcel/core/lib/RequestTracker.js
@@ -133,6 +133,8 @@ class RequestGraph extends _ContentGraph().default {
 
     _defineProperty(this, "incompleteNodeIds", new Set());
 
+    _defineProperty(this, "incompleteNodePromises", new Map());
+
     _defineProperty(this, "globNodeIds", new Set());
 
     _defineProperty(this, "envNodeIds", new Set());
@@ -169,41 +171,36 @@ class RequestGraph extends _ContentGraph().default {
 
 
   addNode(node) {
-    let didNodeExist = this.hasContentKey(node.id);
+    let nodeId = this._contentKeyToNodeId.get(node.id);
 
-    if (!didNodeExist) {
-      let nodeId = super.addNodeByContentKey(node.id, node);
+    if (nodeId != null) {
+      return nodeId;
+    }
 
-      if (node.type === 'glob') {
-        this.globNodeIds.add(nodeId);
-      }
+    nodeId = super.addNodeByContentKey(node.id, node);
 
-      if (node.type === 'env') {
-        this.envNodeIds.add(nodeId);
-      }
-
-      if (node.type === 'option') {
-        this.optionNodeIds.add(nodeId);
-      }
+    if (node.type === 'glob') {
+      this.globNodeIds.add(nodeId);
+    } else if (node.type === 'env') {
+      this.envNodeIds.add(nodeId);
+    } else if (node.type === 'option') {
+      this.optionNodeIds.add(nodeId);
     }
 
-    return this.getNodeIdByContentKey(node.id);
+    return nodeId;
   }
 
   removeNode(nodeId) {
     this.invalidNodeIds.delete(nodeId);
     this.incompleteNodeIds.delete(nodeId);
+    this.incompleteNodePromises.delete(nodeId);
     let node = (0, _nullthrows().default)(this.getNode(nodeId));
 
     if (node.type === 'glob') {
       this.globNodeIds.delete(nodeId);
-    }
-
-    if (node.type === 'env') {
+    } else if (node.type === 'env') {
       this.envNodeIds.delete(nodeId);
-    }
-
-    if (node.type === 'option') {
+    } else if (node.type === 'option') {
       this.optionNodeIds.delete(nodeId);
     }
 
@@ -216,12 +213,6 @@ class RequestGraph extends _ContentGraph().default {
     return node;
   }
 
-  completeRequest(request) {
-    let nodeId = this.getNodeIdByContentKey(request.id);
-    this.invalidNodeIds.delete(nodeId);
-    this.incompleteNodeIds.delete(nodeId);
-  }
-
   replaceSubrequests(requestNodeId, subrequestContentKeys) {
     let subrequestNodeIds = [];
 
@@ -591,7 +582,15 @@ class RequestTracker {
 
     this.graph.incompleteNodeIds.add(requestNodeId);
     this.graph.invalidNodeIds.delete(requestNodeId);
-    return requestNodeId;
+    let {
+      promise,
+      deferred
+    } = (0, _utils().makeDeferredWithPromise)();
+    this.graph.incompleteNodePromises.set(requestNodeId, promise);
+    return {
+      requestNodeId,
+      deferred
+    };
   } // If a cache key is provided, the result will be removed from the node and stored in a separate cache entry
 
 
@@ -631,6 +630,7 @@ class RequestTracker {
   completeRequest(nodeId) {
     this.graph.invalidNodeIds.delete(nodeId);
     this.graph.incompleteNodeIds.delete(nodeId);
+    this.graph.incompleteNodePromises.delete(nodeId);
     let node = this.graph.getNode(nodeId);
 
     if ((node === null || node === void 0 ? void 0 : node.type) === 'request') {
@@ -640,6 +640,7 @@ class RequestTracker {
 
   rejectRequest(nodeId) {
     this.graph.incompleteNodeIds.delete(nodeId);
+    this.graph.incompleteNodePromises.delete(nodeId);
     let node = this.graph.getNode(nodeId);
 
     if ((node === null || node === void 0 ? void 0 : node.type) === 'request') {
@@ -680,7 +681,25 @@ class RequestTracker {
       return this.getRequestResult(request.id);
     }
 
-    let requestNodeId = this.startRequest({
+    if (requestId != null) {
+      let incompletePromise = this.graph.incompleteNodePromises.get(requestId);
+
+      if (incompletePromise != null) {
+        // There is a another instance of this request already running, wait for its completion and reuse its result
+        try {
+          if (await incompletePromise) {
+            // $FlowFixMe[incompatible-type]
+            return this.getRequestResult(request.id);
+          }
+        } catch (e) {// Rerun this request
+        }
+      }
+    }
+
+    let {
+      requestNodeId,
+      deferred
+    } = this.startRequest({
       id: request.id,
       type: request.type
     });
@@ -700,9 +719,11 @@ class RequestTracker {
       });
       (0, _utils2().assertSignalNotAborted)(this.signal);
       this.completeRequest(requestNodeId);
+      deferred.resolve(true);
       return result;
     } catch (err) {
       this.rejectRequest(requestNodeId);
+      deferred.resolve(false);
       throw err;
     } finally {
       this.graph.replaceSubrequests(requestNodeId, [...subRequestContentKeys]);
@@ -779,7 +800,7 @@ class RequestTracker {
     promises.push(this.options.cache.set(requestGraphKey, this.graph));
     let opts = getWatcherOptions(this.options);
 
-    let snapshotPath = this.options.cache._getCachePath(snapshotKey, '.txt');
+    let snapshotPath = _path().default.join(this.options.cacheDir, snapshotKey + '.txt');
 
     promises.push(this.options.inputFS.writeSnapshot(this.options.projectRoot, snapshotPath, opts));
     await Promise.all(promises);
@@ -825,7 +846,7 @@ async function loadRequestGraph(options) {
     let opts = getWatcherOptions(options);
     let snapshotKey = (0, _utils().md5FromString)(`${cacheKey}:snapshot`);
 
-    let snapshotPath = options.cache._getCachePath(snapshotKey, '.txt');
+    let snapshotPath = _path().default.join(options.cacheDir, snapshotKey + '.txt');
 
     let events = await options.inputFS.getEventsSince(options.projectRoot, snapshotPath, opts);
     requestGraph.invalidateUnpredictableNodes();
diff --git a/node_modules/@parcel/core/lib/Transformation.js b/node_modules/@parcel/core/lib/Transformation.js
index a3b981b..e786a7e 100644
--- a/node_modules/@parcel/core/lib/Transformation.js
+++ b/node_modules/@parcel/core/lib/Transformation.js
@@ -392,7 +392,11 @@ class Transformation {
     let isSource = isSourceOverride !== null && isSourceOverride !== void 0 ? isSourceOverride : summarizedIsSource; // If the transformer request passed code rather than a filename,
     // use a hash as the base for the id to ensure it is unique.
 
-    let idBase = code != null ? hash : (0, _utils().normalizeSeparators)(_path().default.relative(this.options.projectRoot, filePath));
+    // let idBase = code != null ? hash : (0, _utils().normalizeSeparators)(_path().default.relative(this.options.projectRoot, filePath));
+    let idBase = (0, _utils().normalizeSeparators)(_path().default.relative(this.options.projectRoot, filePath));
+    if (code != null) {
+      idBase += code;
+    }
     return new (_UncommittedAsset().default)({
       idBase,
       value: (0, _assetUtils().createAsset)({
diff --git a/node_modules/@parcel/core/lib/requests/AssetGraphRequest.js b/node_modules/@parcel/core/lib/requests/AssetGraphRequest.js
index 37c0c2b..7ad255a 100644
--- a/node_modules/@parcel/core/lib/requests/AssetGraphRequest.js
+++ b/node_modules/@parcel/core/lib/requests/AssetGraphRequest.js
@@ -554,10 +554,10 @@ class AssetGraphBuilder {
 
           if (assetGroups.length === 1) {
             let [assetGroupId] = assetGroups;
-            let assetGroup = (0, _nullthrows().default)(this.assetGraph.getNode(assetGroupId));
-            (0, _assert().default)(assetGroup.type === 'asset_group');
+          let assetGroup = (0, _nullthrows().default)(this.assetGraph.getNode(assetGroupId));
+            // (0, _assert().default)(assetGroup.type === 'asset_group');
 
-            if (assetGroup.value.sideEffects === false) {
+            if (assetGroup.type === 'asset_group' && assetGroup.value.sideEffects === false) {
               incomingDep.excluded = true;
             }
           } else {
diff --git a/node_modules/@parcel/core/lib/requests/BundleGraphRequest.js b/node_modules/@parcel/core/lib/requests/BundleGraphRequest.js
index af46342..e57ebc2 100644
--- a/node_modules/@parcel/core/lib/requests/BundleGraphRequest.js
+++ b/node_modules/@parcel/core/lib/requests/BundleGraphRequest.js
@@ -502,9 +502,9 @@ class BundlerRunner {
         });
 
         if (name != null) {
-          if (_path().default.extname(name).slice(1) !== bundle.type) {
-            throw new Error(`Destination name ${name} extension does not match bundle type "${bundle.type}"`);
-          }
+          // if (_path().default.extname(name).slice(1) !== bundle.type) {
+          //   throw new Error(`Destination name ${name} extension does not match bundle type "${bundle.type}"`);
+          // }
 
           internalBundle.name = name;
           let {
